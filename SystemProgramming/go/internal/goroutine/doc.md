# Goroutine について

## goroutine

OS のネイティブなスレッドを扱いやすくした goroutine というものがあり、他の言語におけるスレッドとファイバーのいいところをかね合わせたものである

```go
// 既存の関数を呼び出し
Function()
// 無名関数をその場で作って実行
func() {
// ここに処理を書く
}()
// 別のgoroutine を作って、既存の関数を呼び出し
go Function()
// 別のgoroutine を作って、無名関数をその場で作って実行
go func() {
// 別のgoroutine から呼びたい処理を書く
}()
```

## チャネル

低レベルアクセスの抽象化だけでなく、並列処理のプログラミングにおいて並列で行われる処理の動機を取るのにも使われる
チャネルはキューに並列処理されても正しく処理される機能(CSP というモデル)を実装している
つまり、FIFO で処理が行われる

- 同時に複数の goroutine でチャネルに読み書きを行っても同時に 1 つの gorutine だけが行えるため生合成を保てる
- 読み込み、書き込みで準備ができるまでブロックする機能

終了とタイムアウトの管理に context が使われる

```go
//バッファ無し
tasks := make(chan string)
//バッファ付き
tasks := make(chan string, 10)
```

チャネルにデータを送信したり、受け取る

```go
// データを送信
tasks <- "cmake .."
tasks <- "cmake . --build Debug"
// データを受け取り
task := <-tasks
// データ受け取り＆クローズ判定
task, ok := <-tasks
// データを読み捨てる場合は代入文も不要
<-wait
```

チャネルを閉じる際には、close を呼ぶ close を読んだ後には、読み込み側ではデフォルト値が返ってくるようになり、送信しようとすると、パニックになる
close すると、ループから抜ける

### 複数のチャネルの受け取った順で処理

データが到着したチャネルから順に取り出して処理する場合、あるいはブロックする複数のチャネルの書き込みが完了するのを並列で待受、データが先に送信できたチャネルにのみデータを投入する場合は、select をしようする
select は、for ループに入れて使われることが一般的である

```go
for {
    select {
        case data := <-reader:
        // 読み込んだデータを利用
        case <-exit:
        // ループを抜ける
        break
    }
}
```

## コンテキスト
深いネストや、派生ジョブなど複雑な中でも正しく終了やキャンセル、タイムアウトが実装できる
コンテキストは、親子関係を持つことができ、リクエスト単位で大きなタイムアウト枠を設定して、各サービスのDBリクエストごとにタイムアウトを設定したりして、まとめてキャンセルできる
